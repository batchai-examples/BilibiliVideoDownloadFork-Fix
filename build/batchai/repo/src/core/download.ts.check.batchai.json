{
    "has_issue": true,
    "overall_severity": "major",
    "issues": [
        {
            "short_description": "未处理的Promise拒绝",
            "detailed_explaination": "在下载视频和音频的过程中，Promise可能会被拒绝，但没有适当的错误处理机制。这可能导致未捕获的Promise拒绝，从而影响应用程序的稳定性。",
            "suggestion": "在下载视频和音频的Promise调用中添加错误处理，以确保所有可能的错误都被捕获和处理。",
            "issue_line_begin": 106,
            "issue_line_end": 106,
            "issue_reference_urls": [
                "https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Control_flow#%E5%8F%82%E8%80%83"
            ],
            "severity": "major",
            "severity_reason": "未处理的Promise拒绝可能导致应用程序崩溃或不稳定，影响用户体验。"
        }
    ],
    "fixed_code": "import { IpcMainEvent } from 'electron'\nimport { mergeVideoAudio } from './media'\nimport { randUserAgent, sleep } from '../utils'\nimport { downloadSubtitle } from './subtitle'\nimport { TaskData, SettingData } from '../type'\nimport store from './mainStore'\nimport { throttle } from 'lodash'\nimport { STATUS } from '../assets/data/status'\n\nconst log = require('electron-log')\nconst stream = require('stream')\nconst { promisify } = require('util')\nconst fs = require('fs-extra')\nconst got = require('got')\nconst pipeline = promisify(stream.pipeline)\n\nfunction handleDeleteFile (setting: SettingData, videoInfo: TaskData) {\n  // 删除原视频\n  if (setting.isDelete) {\n    const filePathList = videoInfo.filePathList\n    fs.removeSync(filePathList[2])\n    fs.removeSync(filePathList[3])\n  }\n}\n\nexport default async (videoInfo: TaskData, event: IpcMainEvent, setting: SettingData) =\u003e {\n  log.info(videoInfo.id, videoInfo.title)\n  const takeInfo = store.get(`taskList.${videoInfo.id}`)\n  log.info('mainStore', takeInfo, takeInfo \u0026\u0026 takeInfo.status)\n  // if (takeInfo \u0026\u0026 takeInfo.status === STATUS.FAIL) {\n  //   log.error('×××××!!!!!已经失败过的内容')\n  // }\n  // if (takeInfo \u0026\u0026 takeInfo.status === STATUS.COMPLETED) {\n  //   log.error('×××××已经下载过的内容')\n  // }\n  // if (videoInfo.status === STATUS.FAIL) {\n  //   log.error('已经失败的,又再次下载', videoInfo.title)\n  // }\n\n  const updateData = {\n    id: videoInfo.id,\n    status: STATUS.VIDEO_DOWNLOADING,\n    progress: Math.round(0)\n  }\n  event.reply('download-video-status', updateData)\n  store.set(`taskList.${videoInfo.id}`, {\n    ...videoInfo,\n    ...updateData\n  })\n\n  // 去掉扩展名的文件路径\n  const fileName = videoInfo.filePathList[0].substring(0, videoInfo.filePathList[0].length - 4)\n  // if (setting.isFolder) {\n  // 创建文件夹 存在多p视频时 设置关闭了 下载到单独的文件时 也会需插件合集的目录\n  try {\n    if (!fs.existsSync(videoInfo.fileDir)) {\n      fs.mkdirSync(`${videoInfo.fileDir}`, {\n        recursive: true\n      })\n      if (!fs.existsSync(videoInfo.fileDir))\n      {\n        throw new Error('文件夹无法创建')\n      }\n      log.info(`文件夹创建成功：${videoInfo.fileDir}`)\n    } else {\n      log.info(`文件夹已存在：${videoInfo.fileDir}`)\n    }\n  } catch (error) {\n    log.error(`创建文件夹失败：${error}`)\n    throw new Error(`创建文件夹失败：${error}`)\n  }\n  // }\n  // 下载封面\n  if (setting.isCover) {\n    const imageConfig = {\n      headers: {\n        'User-Agent': randUserAgent(),\n        cookie: `SESSDATA=${setting.SESSDATA}`\n      }\n    }\n    await pipeline(\n      got.stream(videoInfo.cover, imageConfig)\n        .on('error', (error: any) =\u003e {\n          console.log(error)\n        }),\n      fs.createWriteStream(videoInfo.filePathList[1])\n    )\n    log.info(`✅ 下载封面完成 ${videoInfo.title}`)\n  }\n\n  log.info(`下载字幕 \"${JSON.stringify(videoInfo.subtitle)}\"`)\n  // 下载字幕\n  if (setting.isSubtitle \u0026\u0026\n    Array.isArray(videoInfo.subtitle) \u0026\u0026\n    videoInfo.subtitle.length \u003e 0) {\n    downloadSubtitle(fileName, videoInfo.subtitle)\n    log.info(`✅ 下载字幕完成 ${videoInfo.title}`)\n  }\n\n  // 下载弹幕\n  if (setting.isDanmaku) {\n    event.reply('download-danmuku', videoInfo.cid, videoInfo.title, `${fileName}.ass`)\n  }\n\n  const downloadConfig = {\n    headers: {\n      'User-Agent': randUserAgent(),\n      referer: videoInfo.url\n    },\n    cookie: `SESSDATA=${setting.SESSDATA}`\n  }\n  function videoProgressNotify (progress: any) {\n    const updateData = {\n      id: videoInfo.id,\n      status: STATUS.VIDEO_DOWNLOADING,\n      progress: Math.round(progress.percent * 100 * 0.75)\n    }\n    // console.log('id', videoInfo.id, Math.round(progress.percent * 100 * 0.75))\n    event.reply('download-video-status', updateData)\n    store.set(`taskList.${videoInfo.id}`, Object.assign(videoInfo, updateData))\n    //   {\n    //   ...videoInfo,\n    //   ...updateData\n    // })\n  }\n  // 下载视频\n  await pipeline(\n    got.stream(videoInfo.downloadUrl.video, downloadConfig)\n      .on('downloadProgress', throttle(videoProgressNotify, 1000))\n      .on('error', async (error: any) =\u003e {\n        log.error(`视频下载失败：${videoInfo.title}--${error.message}`)\n        log.error(`------${videoInfo.downloadUrl.video}, ${JSON.stringify(downloadConfig)}`)\n        const updateData = {\n          id: videoInfo.id,\n          status: STATUS.FAIL\n        }\n        // store.set(`taskList.${videoInfo.id}`, {\n        //   ...videoInfo,\n        //   ...updateData\n        // })\n        store.set(`taskList.${videoInfo.id}`, Object.assign(videoInfo, updateData))\n        // 防止最后一次节流把错误状态给覆盖掉\n        await sleep(500)\n        event.reply('download-video-status', updateData)\n      }),\n    fs.createWriteStream(videoInfo.filePathList[2])\n  ).catch(error =\u003e {\n    log.error(`视频下载失败：${videoInfo.title}--${error.message}`);\n  });\n\n  log.info(`✅ 下载视频完成 ${videoInfo.title}`)\n\n  await sleep(1000)\n\n  function audioProgressNotify (progress: any) {\n    const updateData = {\n      id: videoInfo.id,\n      status: STATUS.AUDIO_DOWNLOADING,\n      progress: Math.round((progress.percent * 100 * 0.22) + 75)\n    }\n    event.reply('download-video-status', updateData)\n    store.set(`taskList.${videoInfo.id}`, Object.assign(videoInfo, updateData))\n    // store.set(`taskList.${videoInfo.id}`, {\n    //   ...videoInfo,\n    //   ...updateData\n    // })\n  }\n\n  // 下载音频\n  await pipeline(\n    got.stream(videoInfo.downloadUrl.audio, downloadConfig)\n      .on('downloadProgress', throttle(audioProgressNotify, 1000))\n      .on('error', async (error: any) =\u003e {\n        log.error(`音频下载失败：${videoInfo.title} ${error.message}`)\n        const updateData = {\n          id: videoInfo.id,\n          status: STATUS.FAIL\n        }\n        store.set(`taskList.${videoInfo.id}`, Object.assign(videoInfo, updateData))\n        // store.set(`taskList.${videoInfo.id}`, {\n        //   ...videoInfo,\n        //   ...updateData\n        // })\n        // 防止最后一次节流把错误状态给覆盖掉\n        await sleep(500)\n        event.reply('download-video-status', updateData)\n      }),\n    fs.createWriteStream(videoInfo.filePathList[3])\n  ).catch(error =\u003e {\n    log.error(`音频下载失败：${videoInfo.title} ${error.message}`);\n  });\n  log.info(`✅ 下载下载音频 ${videoInfo.title}`)\n\n  await sleep(1000)\n\n  // 合成视频\n  if (setting.isMerge) {\n    const updateData = {\n      id: videoInfo.id,\n      status: STATUS.MERGING,\n      progress: 98\n    }\n    event.reply('download-video-status', updateData)\n    store.set(`taskList.${videoInfo.id}`, {\n      ...videoInfo,\n      ...updateData\n    })\n    try {\n      const res = await mergeVideoAudio(\n        videoInfo.filePathList[2],\n        videoInfo.filePathList[3],\n        videoInfo.filePathList[0]\n      )\n      log.info(`✅ 音视频合成成功：${videoInfo.title} ${res}`)\n      const updateData = {\n        id: videoInfo.id,\n        status: STATUS.COMPLETED,\n        progress: 100\n      }\n      event.reply('download-video-status', updateData)\n      store.set(`taskList.${videoInfo.id}`, {\n        ...videoInfo,\n        ...updateData\n      })\n    } catch (error: any) {\n      log.error(`音视频合成失败：${videoInfo.title} ${error.message}`)\n      const updateData = {\n        id: videoInfo.id,\n        status: STATUS.FAIL\n      }\n      event.reply('download-video-status', updateData)\n      store.set(`taskList.${videoInfo.id}`, {\n        ...videoInfo,\n        ...updateData\n      })\n    } finally {\n      // 删除原视频\n      handleDeleteFile(setting, videoInfo)\n    }\n  } else {\n    const updateData = {\n      id: videoInfo.id,\n      status: STATUS.COMPLETED,\n      progress: 100\n    }\n    event.reply('download-video-status', updateData)\n    store.set(`taskList.${videoInfo.id}`, {\n      ...videoInfo,\n      ...updateData\n    })\n    handleDeleteFile(setting, videoInfo)\n  }\n}\n",
    "original_code": "import { IpcMainEvent } from 'electron'\nimport { mergeVideoAudio } from './media'\nimport { randUserAgent, sleep } from '../utils'\nimport { downloadSubtitle } from './subtitle'\nimport { TaskData, SettingData } from '../type'\nimport store from './mainStore'\nimport { throttle } from 'lodash'\nimport { STATUS } from '../assets/data/status'\n\nconst log = require('electron-log')\nconst stream = require('stream')\nconst { promisify } = require('util')\nconst fs = require('fs-extra')\nconst got = require('got')\nconst pipeline = promisify(stream.pipeline)\n\nfunction handleDeleteFile (setting: SettingData, videoInfo: TaskData) {\n  // 删除原视频\n  if (setting.isDelete) {\n    const filePathList = videoInfo.filePathList\n    fs.removeSync(filePathList[2])\n    fs.removeSync(filePathList[3])\n  }\n}\n\nexport default async (videoInfo: TaskData, event: IpcMainEvent, setting: SettingData) =\u003e {\n  log.info(videoInfo.id, videoInfo.title)\n  const takeInfo = store.get(`taskList.${videoInfo.id}`)\n  log.info('mainStore', takeInfo, takeInfo \u0026\u0026 takeInfo.status)\n  // if (takeInfo \u0026\u0026 takeInfo.status === STATUS.FAIL) {\n  //   log.error('×××××!!!!!已经失败过的内容')\n  // }\n  // if (takeInfo \u0026\u0026 takeInfo.status === STATUS.COMPLETED) {\n  //   log.error('×××××已经下载过的内容')\n  // }\n  // if (videoInfo.status === STATUS.FAIL) {\n  //   log.error('已经失败的,又再次下载', videoInfo.title)\n  // }\n\n  const updateData = {\n    id: videoInfo.id,\n    status: STATUS.VIDEO_DOWNLOADING,\n    progress: Math.round(0)\n  }\n  event.reply('download-video-status', updateData)\n  store.set(`taskList.${videoInfo.id}`, {\n    ...videoInfo,\n    ...updateData\n  })\n\n  // 去掉扩展名的文件路径\n  const fileName = videoInfo.filePathList[0].substring(0, videoInfo.filePathList[0].length - 4)\n  // if (setting.isFolder) {\n  // 创建文件夹 存在多p视频时 设置关闭了 下载到单独的文件时 也会需插件合集的目录\n  try {\n    if (!fs.existsSync(videoInfo.fileDir)) {\n      fs.mkdirSync(`${videoInfo.fileDir}`, {\n        recursive: true\n      })\n      if (!fs.existsSync(videoInfo.fileDir))\n      {\n        throw new Error('文件夹无法创建')\n      }\n      log.info(`文件夹创建成功：${videoInfo.fileDir}`)\n    } else {\n      log.info(`文件夹已存在：${videoInfo.fileDir}`)\n    }\n  } catch (error) {\n    log.error(`创建文件夹失败：${error}`)\n    throw new Error(`创建文件夹失败：${error}`)\n  }\n  // }\n  // 下载封面\n  if (setting.isCover) {\n    const imageConfig = {\n      headers: {\n        'User-Agent': randUserAgent(),\n        cookie: `SESSDATA=${setting.SESSDATA}`\n      }\n    }\n    await pipeline(\n      got.stream(videoInfo.cover, imageConfig)\n        .on('error', (error: any) =\u003e {\n          console.log(error)\n        }),\n      fs.createWriteStream(videoInfo.filePathList[1])\n    )\n    log.info(`✅ 下载封面完成 ${videoInfo.title}`)\n  }\n\n  log.info(`下载字幕 \"${JSON.stringify(videoInfo.subtitle)}\"`)\n  // 下载字幕\n  if (setting.isSubtitle \u0026\u0026\n    Array.isArray(videoInfo.subtitle) \u0026\u0026\n    videoInfo.subtitle.length \u003e 0) {\n    downloadSubtitle(fileName, videoInfo.subtitle)\n    log.info(`✅ 下载字幕完成 ${videoInfo.title}`)\n  }\n\n  // 下载弹幕\n  if (setting.isDanmaku) {\n    event.reply('download-danmuku', videoInfo.cid, videoInfo.title, `${fileName}.ass`)\n  }\n\n  const downloadConfig = {\n    headers: {\n      'User-Agent': randUserAgent(),\n      referer: videoInfo.url\n    },\n    cookie: `SESSDATA=${setting.SESSDATA}`\n  }\n  function videoProgressNotify (progress: any) {\n    const updateData = {\n      id: videoInfo.id,\n      status: STATUS.VIDEO_DOWNLOADING,\n      progress: Math.round(progress.percent * 100 * 0.75)\n    }\n    // console.log('id', videoInfo.id, Math.round(progress.percent * 100 * 0.75))\n    event.reply('download-video-status', updateData)\n    store.set(`taskList.${videoInfo.id}`, Object.assign(videoInfo, updateData))\n    //   {\n    //   ...videoInfo,\n    //   ...updateData\n    // })\n  }\n  // 下载视频\n  await pipeline(\n    got.stream(videoInfo.downloadUrl.video, downloadConfig)\n      .on('downloadProgress', throttle(videoProgressNotify, 1000))\n      .on('error', async (error: any) =\u003e {\n        log.error(`视频下载失败：${videoInfo.title}--${error.message}`)\n        log.error(`------${videoInfo.downloadUrl.video}, ${JSON.stringify(downloadConfig)}`)\n        const updateData = {\n          id: videoInfo.id,\n          status: STATUS.FAIL\n        }\n        // store.set(`taskList.${videoInfo.id}`, {\n        //   ...videoInfo,\n        //   ...updateData\n        // })\n        store.set(`taskList.${videoInfo.id}`, Object.assign(videoInfo, updateData))\n        // 防止最后一次节流把错误状态给覆盖掉\n        await sleep(500)\n        event.reply('download-video-status', updateData)\n      }),\n    fs.createWriteStream(videoInfo.filePathList[2])\n  )\n\n  log.info(`✅ 下载视频完成 ${videoInfo.title}`)\n\n  await sleep(1000)\n\n  function audioProgressNotify (progress: any) {\n    const updateData = {\n      id: videoInfo.id,\n      status: STATUS.AUDIO_DOWNLOADING,\n      progress: Math.round((progress.percent * 100 * 0.22) + 75)\n    }\n    event.reply('download-video-status', updateData)\n    store.set(`taskList.${videoInfo.id}`, Object.assign(videoInfo, updateData))\n    // store.set(`taskList.${videoInfo.id}`, {\n    //   ...videoInfo,\n    //   ...updateData\n    // })\n  }\n\n  // 下载音频\n  await pipeline(\n    got.stream(videoInfo.downloadUrl.audio, downloadConfig)\n      .on('downloadProgress', throttle(audioProgressNotify, 1000))\n      .on('error', async (error: any) =\u003e {\n        log.error(`音频下载失败：${videoInfo.title} ${error.message}`)\n        const updateData = {\n          id: videoInfo.id,\n          status: STATUS.FAIL\n        }\n        store.set(`taskList.${videoInfo.id}`, Object.assign(videoInfo, updateData))\n        // store.set(`taskList.${videoInfo.id}`, {\n        //   ...videoInfo,\n        //   ...updateData\n        // })\n        // 防止最后一次节流把错误状态给覆盖掉\n        await sleep(500)\n        event.reply('download-video-status', updateData)\n      }),\n    fs.createWriteStream(videoInfo.filePathList[3])\n  )\n  log.info(`✅ 下载下载音频 ${videoInfo.title}`)\n\n  await sleep(1000)\n\n  // 合成视频\n  if (setting.isMerge) {\n    const updateData = {\n      id: videoInfo.id,\n      status: STATUS.MERGING,\n      progress: 98\n    }\n    event.reply('download-video-status', updateData)\n    store.set(`taskList.${videoInfo.id}`, {\n      ...videoInfo,\n      ...updateData\n    })\n    try {\n      const res = await mergeVideoAudio(\n        videoInfo.filePathList[2],\n        videoInfo.filePathList[3],\n        videoInfo.filePathList[0]\n      )\n      log.info(`✅ 音视频合成成功：${videoInfo.title} ${res}`)\n      const updateData = {\n        id: videoInfo.id,\n        status: STATUS.COMPLETED,\n        progress: 100\n      }\n      event.reply('download-video-status', updateData)\n      store.set(`taskList.${videoInfo.id}`, {\n        ...videoInfo,\n        ...updateData\n      })\n    } catch (error: any) {\n      log.error(`音视频合成失败：${videoInfo.title} ${error.message}`)\n      const updateData = {\n        id: videoInfo.id,\n        status: STATUS.FAIL\n      }\n      event.reply('download-video-status', updateData)\n      store.set(`taskList.${videoInfo.id}`, {\n        ...videoInfo,\n        ...updateData\n      })\n    } finally {\n      // 删除原视频\n      handleDeleteFile(setting, videoInfo)\n    }\n  } else {\n    const updateData = {\n      id: videoInfo.id,\n      status: STATUS.COMPLETED,\n      progress: 100\n    }\n    event.reply('download-video-status', updateData)\n    store.set(`taskList.${videoInfo.id}`, {\n      ...videoInfo,\n      ...updateData\n    })\n    handleDeleteFile(setting, videoInfo)\n  }\n}\n",
    "path": "src/core/download.ts",
    "model_usage_metrics": {
        "Duration": 24345866868,
        "OpenAiUsage": {
            "completion_tokens": 0,
            "prompt_tokens": 0,
            "total_tokens": 0,
            "completion_tokens_details": {
                "accepted_prediction_tokens": 0,
                "audio_tokens": 0,
                "reasoning_tokens": 0,
                "rejected_prediction_tokens": 0
            },
            "prompt_tokens_details": {
                "audio_tokens": 0,
                "cached_tokens": 0
            }
        }
    }
}